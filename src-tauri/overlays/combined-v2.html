<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3カラム統合オーバーレイ (v2)</title>
  <!-- 共通スタイル -->
  <link rel="stylesheet" href="shared/overlay-common.css">
  <!-- Design Token（テーマ・タイポグラフィ） -->
  <link rel="stylesheet" href="shared/design-tokens.css">
  <!-- 3カラムレイアウト -->
  <link rel="stylesheet" href="shared/layout-v2.css">
  <!-- セットリスト共通スタイル -->
  <link rel="stylesheet" href="shared/setlist-common.css">
  <!-- コンポーネントスタイル -->
  <link rel="stylesheet" href="styles/components.css">
  <style>
    /* combined-v2.html固有のスタイル */
    :root {
      --font-size-setlist: 24px;
    }

    body {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <!-- 3カラムレイアウトルート -->
  <div class="layout-root">
    <!-- 左カラム -->
    <div class="col-left">
      <section id="slot-left-top">
        <!-- 時刻ウィジェット（ClockWidget: 実装済み） -->
      </section>
      <section id="slot-left-topBelow">
        <!-- 天気ウィジェット（WeatherWidget: Open-Meteo API連携済み） -->
      </section>
      <section id="slot-left-middle" class="clamp-box">
        <!-- コメント表示 -->
        <div class="comment-container" id="comment-container"></div>
      </section>
      <section id="slot-left-lower">
        <!-- スーパーチャット（SuperchatCard: 実装済み） -->
      </section>
      <section id="slot-left-bottom">
        <!-- ロゴ（BrandBlock: UI実装済み、設定UIはT29で実装予定） -->
      </section>
    </div>

    <!-- 中央カラム -->
    <div class="col-center">
      <section id="slot-center-full">
        <!-- 主役ステージ（MainAvatarStage: 透明プレースホルダー実装済み） -->
      </section>
    </div>

    <!-- 右カラム -->
    <div class="col-right">
      <section id="slot-right-top">
        <!-- チャンネルバッジ（ChannelBadge: 実装済み） -->
      </section>
      <section id="slot-right-upper" class="clamp-box">
        <!-- セットリスト表示 -->
        <div class="setlist-container" id="setlist-container">
          <div class="setlist-item" id="song-prev">
            <span class="song-number">-</span>
            <div class="song-info">
              <div class="song-title">-</div>
              <div class="song-artist"></div>
            </div>
          </div>
          <div class="setlist-item current" id="song-current">
            <span class="song-number">-</span>
            <div class="song-info">
              <div class="song-title">待機中...</div>
              <div class="song-artist"></div>
            </div>
            <span class="song-status">NOW</span>
          </div>
          <div class="setlist-item" id="song-next">
            <span class="song-number">-</span>
            <div class="song-info">
              <div class="song-title">-</div>
              <div class="song-artist"></div>
            </div>
          </div>
        </div>
      </section>
      <div class="right-lower-grid">
        <section id="slot-right-lowerLeft">
          <!-- KPI（KPIBlock: UI実装済み、データ連携はT26で実装予定） -->
        </section>
        <section id="slot-right-lowerRight">
          <!-- 待機キュー（QueueList: UI実装済み、キュー管理はT27で実装予定） -->
        </section>
      </div>
      <section id="slot-right-bottom">
        <!-- 告知（PromoPanel: UI実装済み、コンテンツ管理はT28で実装予定） -->
      </section>
    </div>
  </div>

  <!-- 共通スクリプト -->
  <script src="shared/slots.js"></script>
  <script src="shared/comment-renderer.js?v=2"></script>
  <script src="shared/overlay-core.js?v=1"></script>

  <!-- パフォーマンス最適化モジュール（T24） -->
  <script src="shared/clamp-constants.js"></script>
  <script src="shared/update-batcher.js"></script>
  <script src="shared/density-manager.js"></script>

  <!-- コンポーネントシステム（base-component.jsは他のコンポーネントが継承するため先に読み込む） -->
  <script src="components/base-component.js"></script>
  <script src="shared/component-registry.js"></script>

  <!-- コンポーネント -->
  <script src="components/clock-widget.js"></script>
  <script src="components/weather-widget.js"></script>
  <script src="components/brand-block.js"></script>
  <script src="components/main-avatar-stage.js"></script>
  <script src="components/channel-badge.js"></script>
  <script src="components/kpi-block.js"></script>
  <script src="components/promo-panel.js"></script>
  <script src="components/queue-list.js"></script>
  <script src="components/superchat-card.js"></script>

  <script>
    // 共通モジュールから関数を取得
    const {
      isValidHexColor,
      isValidNumber,
      sanitizeFontFamily,
      createCommentElement,
      removeCommentWithAnimation,
      CommentQueueManager
    } = window.CommentRenderer;

    const {
      DEBUG,
      WS_URL,
      API_BASE_URL,
      SETTINGS_FETCH_TIMEOUT,
      WebSocketManager,
      SettingsFetcher,
      PostMessageHandler,
      updateSetlistDisplay,
      fetchLatestSetlist
    } = window.OverlayCore;

    // プレビューモード判定（設定画面のiframeプレビュー時はtrue）
    const isPreviewMode = new URLSearchParams(window.location.search).get('preview') === 'true';

    // ===== 設定 =====
    let showAvatar = true;
    let showArtist = true;
    let commentEnabled = true;
    let setlistEnabled = true;

    // ウィジェット表示のデフォルト設定（issues/016: オプショナルフィールドのフォールバック用）
    const DEFAULT_WIDGET_SETTINGS = {
      clock: true, weather: true, comment: true, superchat: true, logo: true,
      setlist: true, kpi: true, tanzaku: true, announcement: true
    };

    // ウィジェットID定数（issues/020: マジックナンバー定数化）
    const WIDGET_IDS = ['clock', 'weather', 'comment', 'superchat', 'logo', 'setlist', 'kpi', 'tanzaku', 'announcement'];

    // Google Fonts読み込み済みフラグ（重複読み込み防止）
    const loadedGoogleFonts = new Set();

    // フォントプリセット定義（issues/020: マジックナンバー定数化）
    const FONT_GOOGLE_MAP = {
      'noto-sans-jp': 'Noto+Sans+JP:wght@400;500;700',
      'm-plus-1': 'M+PLUS+1:wght@400;500;700',
    };
    const FONT_FAMILY_MAP = {
      'noto-sans-jp': "'Noto Sans JP', sans-serif",
      'm-plus-1': "'M PLUS 1', sans-serif",
      'yu-gothic': "'Yu Gothic', 'YuGothic', sans-serif",
      'meiryo': "'Meiryo', sans-serif",
      'system': null, // customFontFamilyを使用
    };

    // issues/001: URLバリデーション（Google Fonts専用）
    function validateGoogleFontsUrl(url) {
      if (!url || typeof url !== 'string') return false;
      try {
        const parsed = new URL(url);
        return parsed.hostname === 'fonts.googleapis.com';
      } catch {
        return false;
      }
    }

    // Google Fonts動的読み込み
    function loadGoogleFont(fontSpec) {
      if (!fontSpec || loadedGoogleFonts.has(fontSpec)) return;

      const url = `https://fonts.googleapis.com/css2?family=${fontSpec}&display=swap`;
      if (!validateGoogleFontsUrl(url)) return;

      const link = document.createElement('link');
      link.rel = 'stylesheet';
      link.href = url;
      document.head.appendChild(link);
      loadedGoogleFonts.add(fontSpec);
      if (DEBUG) console.log(`[Font] Loaded Google Font: ${fontSpec}`);
    }

    // issues/013: 防御的プログラミング - テーマ設定適用
    function applyThemeSettings(themeSettings) {
      if (!themeSettings || typeof themeSettings !== 'object' || Array.isArray(themeSettings)) {
        if (DEBUG) console.warn('[Theme] Invalid themeSettings, skipping');
        return;
      }

      const root = document.documentElement;

      // グローバルカラー
      if (themeSettings.globalPrimaryColor && isValidHexColor(themeSettings.globalPrimaryColor)) {
        root.style.setProperty('--primary-color', themeSettings.globalPrimaryColor);
      }

      // ウィジェット個別カラー
      const overrides = themeSettings.widgetColorOverrides || {};
      WIDGET_IDS.forEach(id => {
        const color = overrides[id] || themeSettings.globalPrimaryColor;
        if (color && isValidHexColor(color)) {
          root.style.setProperty(`--widget-${id}-color`, color);
        }
      });

      // CSS変数が反映されない場合のフォールバック: 直接スタイルを適用
      // (ブラウザキャッシュの古いCSSファイル対策)
      applyDirectWidgetColors(themeSettings);

      // フォント設定
      applyFontSettings(themeSettings);
    }

    // ウィジェットに直接カラーを適用（CSS変数フォールバック）
    // ブラウザキャッシュの古いCSSファイル対策
    function applyDirectWidgetColors(themeSettings) {
      if (!themeSettings || typeof themeSettings !== 'object') return;

      const overrides = themeSettings.widgetColorOverrides || {};
      const globalColor = themeSettings.globalPrimaryColor;

      // ウィジェットIDとCSSセレクタのマッピング（テキストカラー用）
      const WIDGET_SELECTORS = {
        clock: ['.clock-time', '.clock-date'],
        weather: ['.weather-widget'],
        comment: ['#comment-container'], // コンテナに設定し、子要素は継承
        superchat: [], // スパチャはTierカラーを使用
        logo: ['.brand-block', '.brand-text'],
        setlist: ['.song-title', '.song-artist', '.song-number'],
        kpi: ['.kpi-main', '.kpi-sub'],
        tanzaku: ['.queue-list', '.queue-item'],
        announcement: ['.promo-panel', '.promo-content'],
      };

      // 背景色を適用する要素のマッピング
      const WIDGET_BG_SELECTORS = {
        setlist: ['.song-status'],
      };

      WIDGET_IDS.forEach(id => {
        const color = overrides[id] || globalColor;
        if (!color || !isValidHexColor(color)) return;

        // テキストカラーを適用
        const selectors = WIDGET_SELECTORS[id] || [];
        selectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(el => {
            el.style.color = color;
          });
        });

        // 背景色を適用
        const bgSelectors = WIDGET_BG_SELECTORS[id] || [];
        bgSelectors.forEach(selector => {
          const elements = document.querySelectorAll(selector);
          elements.forEach(el => {
            el.style.backgroundColor = color;
          });
        });
      });

      // コメントコンテナとその子要素にカラーを適用
      const commentColor = overrides['comment'] || globalColor;
      if (commentColor && isValidHexColor(commentColor)) {
        // グローバル変数を更新（MutationObserver用）
        currentCommentColor = commentColor;

        const commentContainer = document.getElementById('comment-container');
        if (commentContainer) {
          // コンテナにカラーを設定（継承用）
          commentContainer.style.color = commentColor;
          commentContainer.style.setProperty('--widget-comment-color', commentColor);

          // 既存のコメント要素にも直接適用（キャッシュ対策）
          commentContainer.querySelectorAll('.name, .message').forEach(el => {
            el.style.color = commentColor;
          });
        }

        // MutationObserverをセットアップ（初回のみ）
        setupCommentColorObserver();
      }
    }

    // コメント用MutationObserver（新規コメントにテーマカラーを適用）
    let commentColorObserver = null;
    let currentCommentColor = null;

    function setupCommentColorObserver() {
      const commentContainer = document.getElementById('comment-container');
      if (!commentContainer || commentColorObserver) return;

      commentColorObserver = new MutationObserver((mutations) => {
        if (!currentCommentColor) return;

        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(node => {
            if (node.nodeType === Node.ELEMENT_NODE) {
              // 追加された要素内の.nameと.messageにカラーを適用
              if (node.classList?.contains('name') || node.classList?.contains('message')) {
                node.style.color = currentCommentColor;
              }
              node.querySelectorAll?.('.name, .message').forEach(el => {
                el.style.color = currentCommentColor;
              });
            }
          });
        });
      });

      commentColorObserver.observe(commentContainer, {
        childList: true,
        subtree: true
      });
    }

    // フォント設定適用
    function applyFontSettings(themeSettings) {
      if (!themeSettings || typeof themeSettings !== 'object') return;

      const root = document.documentElement;
      const fontPreset = themeSettings.fontPreset || 'yu-gothic';

      // Google Fonts読み込み
      if (FONT_GOOGLE_MAP[fontPreset]) {
        loadGoogleFont(FONT_GOOGLE_MAP[fontPreset]);
      }

      // フォントファミリー適用
      let fontFamily = FONT_FAMILY_MAP[fontPreset];
      if (fontPreset === 'system' && themeSettings.customFontFamily) {
        fontFamily = sanitizeFontFamily(themeSettings.customFontFamily);
      }

      if (fontFamily) {
        root.style.setProperty('--font-family', fontFamily);
      }
    }

    // パフォーマンス最適化（T24）: バッチ更新と過密検出
    // letを使用: bfcache復元時に再初期化するため
    let updateBatcher = new UpdateBatcher({ batchInterval: 150 });
    let densityManager = new DensityManager();

    // ===== URL/API設定適用 =====
    function applyUrlSettings() {
      const params = new URLSearchParams(window.location.search);
      const root = document.documentElement;

      const primaryColor = params.get('primaryColor');
      if (primaryColor && isValidHexColor(primaryColor)) {
        root.style.setProperty('--primary-color', primaryColor);
      }

      const fontFamily = params.get('fontFamily');
      const sanitizedFont = sanitizeFontFamily(fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      const commentFontSize = params.get('commentFontSize');
      if (commentFontSize && isValidNumber(commentFontSize, 8, 72)) {
        root.style.setProperty('--font-size-message', commentFontSize + 'px');
      }

      const showAvatarParam = params.get('showAvatar');
      if (showAvatarParam !== null) {
        showAvatar = showAvatarParam === 'true';
        updateAvatarVisibility();
      }

      const commentEnabledParam = params.get('commentEnabled');
      if (commentEnabledParam !== null) {
        commentEnabled = commentEnabledParam === 'true';
        updateVisibility();
      }

      const setlistFontSize = params.get('setlistFontSize');
      if (setlistFontSize && isValidNumber(setlistFontSize, 8, 72)) {
        root.style.setProperty('--font-size-setlist', setlistFontSize + 'px');
      }

      const showArtistParam = params.get('showArtist');
      if (showArtistParam !== null) {
        showArtist = showArtistParam === 'true';
        updateArtistVisibility();
      }

      const setlistEnabledParam = params.get('setlistEnabled');
      if (setlistEnabledParam !== null) {
        setlistEnabled = setlistEnabledParam === 'true';
        updateVisibility();
      }
    }

    function updateVisibility() {
      const commentSlot = document.getElementById('slot-left-middle');
      const setlistSlot = document.getElementById('slot-right-upper');
      commentSlot.classList.toggle('hidden', !commentEnabled);
      setlistSlot.classList.toggle('hidden', !setlistEnabled);
    }

    function updateAvatarVisibility() {
      document.querySelectorAll('.avatar').forEach(avatar => {
        avatar.style.display = showAvatar ? 'block' : 'none';
      });
    }

    function updateArtistVisibility() {
      document.querySelectorAll('.song-artist').forEach(artist => {
        artist.style.display = showArtist ? 'block' : 'none';
      });
    }

    // ===== WebSocket設定更新 =====
    // 天気ウィジェットの位置マッピング
    const WEATHER_POSITION_MAP = {
      'left-top': 'left.topBelow',
      'left-bottom': 'left.bottom',
      'right-top': 'right.top',
      'right-bottom': 'right.bottom',
    };
    let currentWeatherPosition = null;

    function applySettingsUpdate(settings) {
      const root = document.documentElement;

      if (settings.primaryColor && isValidHexColor(settings.primaryColor)) {
        root.style.setProperty('--primary-color', settings.primaryColor);
      }

      const sanitizedFont = sanitizeFontFamily(settings.fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      if (settings.comment) {
        if (settings.comment.fontSize && isValidNumber(settings.comment.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-message', settings.comment.fontSize + 'px');
        }
        if (settings.comment.showAvatar !== undefined) {
          showAvatar = settings.comment.showAvatar;
          updateAvatarVisibility();
        }
        if (settings.comment.enabled !== undefined) {
          commentEnabled = settings.comment.enabled;
          updateVisibility();
        }
      }

      if (settings.setlist) {
        if (settings.setlist.fontSize && isValidNumber(settings.setlist.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-setlist', settings.setlist.fontSize + 'px');
        }
        if (settings.setlist.showArtist !== undefined) {
          showArtist = settings.setlist.showArtist;
          updateArtistVisibility();
        }
        if (settings.setlist.enabled !== undefined) {
          setlistEnabled = settings.setlist.enabled;
          updateVisibility();
        }
      }

      // 天気ウィジェット設定
      if (settings.weather) {
        applyWeatherSettings(settings.weather);
      }

      // パフォーマンス設定
      if (settings.performance) {
        applyPerformanceSettings(settings.performance);
      }

      // ウィジェット表示設定（issues/016: 新フィールドはオプショナル、デフォルト値を設定）
      // settings.widget が undefined/null の場合はデフォルト（全表示）を適用
      applyWidgetVisibility(settings.widget || DEFAULT_WIDGET_SETTINGS);

      // スパチャ設定
      if (settings.superchat) {
        applySuperchatSettings(settings.superchat);
      }

      // テーマ設定（カラー・フォント統合）
      if (settings.themeSettings) {
        applyThemeSettings(settings.themeSettings);
      }
    }

    // スパチャ設定を適用
    function applySuperchatSettings(superchatSettings) {
      if (!superchatSettings || typeof superchatSettings !== 'object') return;

      const superchatComponent = ComponentRegistry.getInstance('left.lower');
      if (superchatComponent && typeof superchatComponent.updateSettings === 'function') {
        superchatComponent.updateSettings(superchatSettings);
      }
    }

    // ウィジェット表示/非表示を適用
    function applyWidgetVisibility(widgetSettings) {
      // issues/013: 防御的プログラミング - オブジェクト型のガード
      // Array.isArrayチェック追加: typeof [] === 'object' がtrueになるため
      if (!widgetSettings || typeof widgetSettings !== 'object' || Array.isArray(widgetSettings)) {
        console.warn('[Widget] Invalid widgetSettings, skipping');
        return;
      }

      const WIDGET_SLOT_MAP = {
        clock: 'left.top',
        weather: 'left.topBelow',
        comment: 'left.middle',
        superchat: 'left.lower',
        logo: 'left.bottom',
        setlist: 'right.upper',
        kpi: 'right.lowerLeft',
        tanzaku: 'right.lowerRight',
        announcement: 'right.bottom',
      };

      for (const [key, slotId] of Object.entries(WIDGET_SLOT_MAP)) {
        const enabled = widgetSettings[key] !== false;
        // SlotManagerはDOMContentLoaded後に初期化されるが、
        // WebSocketメッセージが先に到着するケースを防御的に処理
        // 無効なslotIdの場合はSlotManager内部でconsole.warnが出力される
        if (typeof SlotManager !== 'undefined') {
          SlotManager.setVisibility(slotId, enabled);
        }
      }
    }

    function applyPerformanceSettings(performanceSettings) {
      const threshold = performanceSettings.densityThreshold;
      if (typeof threshold === 'number' && densityManager) {
        densityManager.setThreshold(threshold);
        if (DEBUG) console.log(`[Performance] Density threshold set to ${threshold}`);
      }
    }

    function applyWeatherSettings(weatherSettings) {
      const enabled = weatherSettings.enabled !== false;
      const position = weatherSettings.position || 'left-top';
      const mountPoint = WEATHER_POSITION_MAP[position] || 'left.topBelow';

      // 無効化された場合はアンマウント
      if (!enabled) {
        if (currentWeatherPosition) {
          ComponentRegistry.unmount(currentWeatherPosition);
          currentWeatherPosition = null;
        }
        return;
      }

      // 位置が変更された場合は再マウント
      if (currentWeatherPosition !== mountPoint) {
        // 古い位置からアンマウント
        if (currentWeatherPosition) {
          ComponentRegistry.unmount(currentWeatherPosition);
        }
        // 新しい位置にマウント
        ComponentRegistry.mount(mountPoint, 'WeatherWidget', {});
        currentWeatherPosition = mountPoint;
      }
    }

    // ===== コメント機能 =====
    function trimOverflowingComments() {
      const container = document.getElementById('comment-container');
      const slot = document.getElementById('slot-left-middle');
      const slotRect = slot.getBoundingClientRect();
      const comments = Array.from(container.querySelectorAll('.comment:not(.removing)'));

      comments.forEach(comment => {
        const rect = comment.getBoundingClientRect();
        if (rect.top < slotRect.top - 10) {
          removeCommentWithAnimation(comment);
        }
      });
    }

    // コメントキュー初期化
    const commentQueue = new CommentQueueManager({
      onAddComment: (comment) => {
        const container = document.getElementById('comment-container');
        if (document.querySelector(`[data-id="${CSS.escape(comment.id)}"]`)) return;

        const el = createCommentElement(comment, showAvatar);
        container.appendChild(el);

        requestAnimationFrame(() => {
          trimOverflowingComments();
        });
      }
    });

    // ===== セットリスト機能 =====
    let currentSetlist = { songs: [], currentIndex: -1 };

    // セットリスト要素のキャッシュ
    const setlistElements = {
      prevEl: document.getElementById('song-prev'),
      currentEl: document.getElementById('song-current'),
      nextEl: document.getElementById('song-next')
    };

    function updateSetlist(data) {
      currentSetlist = data;
      updateSetlistDisplay(data, setlistElements, updateArtistVisibility);
    }

    // ===== 設定フェッチャー =====
    const settingsFetcher = new SettingsFetcher({
      apiBaseUrl: API_BASE_URL,
      timeout: SETTINGS_FETCH_TIMEOUT,
      onSettingsApply: (settings) => {
        applySettingsUpdate(settings);
        applyUrlSettings();
      }
    });

    // ===== WebSocket接続マネージャー =====
    const wsManager = new WebSocketManager({
      url: WS_URL,
      onOpen: () => {
        if (!settingsFetcher.hasFetched()) {
          settingsFetcher.fetchAndApply();
        }
        fetchLatestSetlist(API_BASE_URL, updateSetlist);
      },
      onMessage: (data) => {
        switch (data.type) {
          case 'comment:add':
            // instant=trueなら即時表示（gRPC/InnerTube）、falseならバッファリング（公式APIポーリング）
            if (data.instant) {
              commentQueue.addInstant(data.payload);
            } else {
              // buffer_interval_ms が指定されていればバッファ間隔を更新
              commentQueue.queue(data.payload, data.buffer_interval_ms);
            }
            break;
          case 'comment:remove':
            const el = document.querySelector(`[data-id="${CSS.escape(data.payload?.id)}"]`);
            if (el) removeCommentWithAnimation(el);
            break;
          case 'setlist:update':
            updateSetlist({
              songs: data.payload.songs.map(s => ({ title: s.title, artist: s.artist })),
              currentIndex: data.payload.currentIndex
            });
            break;
          case 'settings:update':
            settingsFetcher.incrementVersion();
            applySettingsUpdate(data.payload);
            applyUrlSettings();
            break;

          // 新規コンポーネント用イベント（T24: バッチ更新 + 過密検出）
          case 'kpi:update':
            updateBatcher.queue('KPIBlock', data.payload);
            densityManager.recordUpdate('right.lowerLeft');
            break;
          case 'queue:update':
            updateBatcher.queue('QueueList', data.payload);
            densityManager.recordUpdate('right.lowerRight');
            break;
          case 'promo:update':
            updateBatcher.queue('PromoPanel', data.payload);
            densityManager.recordUpdate('right.bottom');
            break;
          case 'weather:update':
            // 天気ウィジェットは左カラム（slot-left-topBelow）に配置されるため、
            // 右下エリアの過密検出（densityManager）には記録しない。
            // 右下エリア: right.lowerLeft, right.lowerRight, right.bottom のみが対象
            updateBatcher.queue('WeatherWidget', data.payload);
            break;
          case 'template:update':
            if (data.payload && data.payload.components) {
              ComponentRegistry.applyTemplate(data.payload.components);
            }
            break;

          // スパチャウィジェット
          // プレビューモードではpostMessage経由で受信するため、WebSocket経由はスキップ
          case 'superchat:add':
            if (!isPreviewMode) {
              const superchatCard = ComponentRegistry.getInstance('left.lower');
              if (superchatCard && typeof superchatCard.addSuperchat === 'function') {
                superchatCard.addSuperchat(data.payload);
              }
            }
            break;
          case 'superchat:remove':
            if (!isPreviewMode) {
              const superchatCardForRemove = ComponentRegistry.getInstance('left.lower');
              if (superchatCardForRemove && typeof superchatCardForRemove.removeSuperchat === 'function') {
                superchatCardForRemove.removeSuperchat(data.payload?.id);
              }
            }
            break;
        }
      }
    });

    // ===== PostMessageハンドラ（プレビュー専用） =====
    // 設定画面のiframeプレビューからの即時反映用
    // OBS側のオーバーレイには影響なし（親ウィンドウが異なるため）
    const postMessageHandler = new PostMessageHandler({
      onSettingsUpdate: (payload) => {
        // issues/013: 各フィールドの存在チェックはapplySettingsUpdate内で実施
        applySettingsUpdate(payload);
      },
      onSuperchatAdd: (payload) => {
        // スパチャ追加（プレビュー用）
        const superchatCard = ComponentRegistry.getInstance('left.lower');
        if (superchatCard && typeof superchatCard.addSuperchat === 'function') {
          superchatCard.addSuperchat(payload);
        }
      },
      onSuperchatRemove: (id) => {
        // スパチャ削除（プレビュー用）
        const superchatCard = ComponentRegistry.getInstance('left.lower');
        if (superchatCard && typeof superchatCard.removeSuperchat === 'function') {
          superchatCard.removeSuperchat(id);
        }
      }
    });

    // ===== ウィンドウリサイズ =====
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        trimOverflowingComments();
      }, 100);
    });

    // ===== コンポーネント初期化 =====
    function initDefaultComponents() {
      // 左カラム
      ComponentRegistry.mount('left.top', 'ClockWidget', {});
      // WeatherWidgetは設定に基づいて配置されるため、ここではマウントしない
      ComponentRegistry.mount('left.lower', 'SuperchatCard', {});
      ComponentRegistry.mount('left.bottom', 'BrandBlock', {});

      // 中央カラム
      ComponentRegistry.mount('center.full', 'MainAvatarStage', {});

      // 右カラム
      ComponentRegistry.mount('right.top', 'ChannelBadge', { style: { label: 'LIVE' } });
      ComponentRegistry.mount('right.lowerLeft', 'KPIBlock', {});
      ComponentRegistry.mount('right.lowerRight', 'QueueList', { rules: { maxItems: 6 } });
      ComponentRegistry.mount('right.bottom', 'PromoPanel', {});

      // 天気ウィジェットをデフォルト設定で初期化
      applyWeatherSettings({ enabled: true, position: 'left-top' });
    }

    // URLパラメータでコンポーネントを制御
    function applyComponentSettings() {
      const params = new URLSearchParams(window.location.search);

      // 各コンポーネントの有効/無効
      const componentsEnabled = params.get('components');
      if (componentsEnabled === 'false') {
        // コンポーネントを無効にする場合はスキップ
        return;
      }

      // デフォルトコンポーネントを初期化
      initDefaultComponents();
    }

    // ===== クリーンアップ =====
    // オーバーレイのアンロード/リロード時にタイマーをクリーンアップ
    //
    // イベント発火順序と設計:
    // 1. beforeunload: ページ離脱前に発火（bfcache対応ブラウザでも発火）
    // 2. pagehide: ページ非表示時に発火（event.persistedでbfcache判定可能）
    //
    // bfcache対応のため:
    // - beforeunloadではcleanupを呼ばない（bfcacheを無効化しないため）
    // - pagehideでevent.persisted=falseの場合のみcleanup
    // - OBSブラウザソース等のbfcache非対応環境ではpagehide(persisted=false)で確実にクリーンアップ

    function cleanup() {
      // WebSocketマネージャーのクリーンアップ（再接続タイマーも含む）
      wsManager.cleanup();

      // PostMessageハンドラのクリーンアップ
      postMessageHandler.cleanup();

      // MutationObserverのクリーンアップ
      if (commentColorObserver) {
        commentColorObserver.disconnect();
        commentColorObserver = null;
      }

      if (densityManager) {
        densityManager.destroy();
      }
      if (updateBatcher) {
        updateBatcher.destroy();
      }
    }

    window.addEventListener('pagehide', (event) => {
      // bfcacheに保存される場合はcleanupを呼ばない（後でpageshowで復元するため）
      // event.persisted=true: bfcacheに保存される → クリーンアップしない
      // event.persisted=false: 通常のページ離脱（OBS含む） → クリーンアップ
      if (!event.persisted) {
        cleanup();
      }
    });

    // 注: beforeunloadはbfcacheを無効化する可能性があるため、cleanupを呼ばない
    // OBSブラウザソース等のbfcache非対応環境でも、pagehide(persisted=false)で
    // 確実にクリーンアップされるため問題なし

    // bfcache復元時の再接続
    window.addEventListener('pageshow', (event) => {
      if (event.persisted) {
        // bfcacheから復元された場合
        if (DEBUG) console.log('Page restored from bfcache, reconnecting...');

        // 設定フェッチャーをリセット（復元後に必ず再取得）
        settingsFetcher.reset();

        // マネージャーを再作成（destroyされている可能性があるため）
        // 注: bfcache復元時はbeforeunload/pagehideでcleanupが呼ばれていないため、
        //     通常はdestroyされていないが、念のためチェック
        if (!densityManager || densityManager.isDestroyed()) {
          densityManager = new DensityManager();
          if (DEBUG) console.log('DensityManager reinitialized after bfcache restore');
        }
        // UpdateBatcherも再作成（destroyされている場合）
        if (!updateBatcher || updateBatcher.isDestroyed()) {
          updateBatcher = new UpdateBatcher({ batchInterval: 150 });
          if (DEBUG) console.log('UpdateBatcher reinitialized after bfcache restore');
        }

        // WebSocketマネージャーを再初期化
        wsManager.reinitialize();

        // PostMessageハンドラを再初期化（issues/010: bfcache復元時の対応）
        postMessageHandler.reinitialize();
      }
    });

    // ===== 初期化 =====
    applyUrlSettings();
    settingsFetcher.fetchAndApply();
    applyComponentSettings();
    wsManager.connect();
  </script>
</body>

</html>
