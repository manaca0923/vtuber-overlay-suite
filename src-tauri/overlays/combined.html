<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Combined Overlay</title>
  <!-- 共通スタイル -->
  <link rel="stylesheet" href="shared/overlay-common.css">
  <style>
    /* combined.html固有のスタイル */
    :root {
      --font-size-setlist: 24px;
    }

    body {
      width: 100vw;
      height: 100vh;
    }

    /* ===== レイアウトコンテナ ===== */
    #overlay-root {
      position: fixed;
      inset: 0;
      display: grid;
      padding: 16px;
      gap: 16px;
    }

    /* レイアウトプリセット */
    #overlay-root.layout-streaming {
      grid-template-columns: 400px 1fr;
      grid-template-rows: 1fr auto;
      grid-template-areas:
        "comment ."
        "comment setlist";
    }

    #overlay-root.layout-talk {
      grid-template-columns: 200px 1fr 400px;
      grid-template-rows: 1fr;
      grid-template-areas: "setlist . comment";
    }

    #overlay-root.layout-music {
      grid-template-columns: 1fr 400px;
      grid-template-rows: auto 1fr auto;
      grid-template-areas:
        ". comment"
        ". ."
        "setlist setlist";
    }

    #overlay-root.layout-gaming {
      grid-template-columns: 400px 1fr 200px;
      grid-template-rows: 1fr;
      grid-template-areas: "comment . setlist";
    }

    #overlay-root.layout-custom {
      grid-template-columns: 400px 1fr;
      grid-template-rows: 1fr auto;
      grid-template-areas:
        "comment ."
        "comment setlist";
    }

    /* ===== コメントエリア ===== */
    #comment-area {
      grid-area: comment;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      min-height: 0;
    }

    #comment-area.position-top {
      justify-content: flex-start;
    }

    #comment-container {
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      gap: var(--comment-gap);
      overflow: hidden;
      flex: 1;
      min-height: 0;
    }

    /* ===== セットリストエリア ===== */
    #setlist-area {
      grid-area: setlist;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    #setlist-container {
      background: rgba(0, 0, 0, 0.6);
      border-radius: 12px;
      backdrop-filter: blur(8px);
      padding: 16px 24px;
      min-width: 300px;
      max-width: 100%;
    }

    .setlist-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 0;
      opacity: 0.5;
      transition: all 0.3s ease;
    }

    .setlist-item.current {
      opacity: 1;
      transform: scale(1.05);
    }

    .setlist-item.current .song-title {
      color: var(--primary-color);
    }

    .song-number {
      font-size: 14px;
      font-weight: bold;
      min-width: 24px;
      text-align: center;
      color: var(--primary-color);
    }

    .song-info {
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .song-title {
      font-size: var(--font-size-setlist);
      font-weight: bold;
      text-shadow: var(--text-shadow);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .song-artist {
      font-size: 14px;
      opacity: 0.7;
      text-shadow: var(--text-shadow);
    }

    .song-status {
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 4px;
      background: var(--primary-color);
    }
  </style>
</head>

<body>
  <div id="overlay-root" class="layout-streaming">
    <div id="comment-area">
      <div id="comment-container"></div>
    </div>
    <div id="setlist-area">
      <div id="setlist-container">
        <div class="setlist-item" id="song-prev">
          <span class="song-number">-</span>
          <div class="song-info">
            <div class="song-title">-</div>
            <div class="song-artist"></div>
          </div>
        </div>
        <div class="setlist-item current" id="song-current">
          <span class="song-number">-</span>
          <div class="song-info">
            <div class="song-title">待機中...</div>
            <div class="song-artist"></div>
          </div>
          <span class="song-status">NOW</span>
        </div>
        <div class="setlist-item" id="song-next">
          <span class="song-number">-</span>
          <div class="song-info">
            <div class="song-title">-</div>
            <div class="song-artist"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- 共通スクリプト -->
  <script src="shared/comment-renderer.js?v=2"></script>
  <script src="shared/overlay-core.js?v=1"></script>
  <script>
    // 共通モジュールから関数を取得
    const {
      isValidHexColor,
      isValidNumber,
      sanitizeFontFamily,
      createCommentElement,
      removeCommentWithAnimation,
      CommentQueueManager
    } = window.CommentRenderer;

    const {
      WS_URL,
      API_BASE_URL,
      SETTINGS_FETCH_TIMEOUT,
      WebSocketManager,
      SettingsFetcher,
      updateSetlistDisplay,
      fetchLatestSetlist
    } = window.OverlayCore;

    // ===== 設定 =====
    let showAvatar = true;
    let showArtist = true;
    let commentEnabled = true;
    let setlistEnabled = true;
    let currentLayout = 'streaming';

    const VALID_LAYOUTS = ['streaming', 'talk', 'music', 'gaming', 'custom'];

    // ===== URL/API設定適用 =====
    function applyUrlSettings() {
      const params = new URLSearchParams(window.location.search);
      const root = document.documentElement;

      const layout = params.get('layout');
      if (layout && VALID_LAYOUTS.includes(layout)) {
        currentLayout = layout;
        applyLayout(layout);
      }

      const primaryColor = params.get('primaryColor');
      if (primaryColor && isValidHexColor(primaryColor)) {
        root.style.setProperty('--primary-color', primaryColor);
      }

      const fontFamily = params.get('fontFamily');
      const sanitizedFont = sanitizeFontFamily(fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      const commentFontSize = params.get('commentFontSize');
      if (commentFontSize && isValidNumber(commentFontSize, 8, 72)) {
        root.style.setProperty('--font-size-message', commentFontSize + 'px');
      }

      const showAvatarParam = params.get('showAvatar');
      if (showAvatarParam !== null) {
        showAvatar = showAvatarParam === 'true';
        updateAvatarVisibility();
      }

      const commentEnabledParam = params.get('commentEnabled');
      if (commentEnabledParam !== null) {
        commentEnabled = commentEnabledParam === 'true';
        updateVisibility();
      }

      const setlistFontSize = params.get('setlistFontSize');
      if (setlistFontSize && isValidNumber(setlistFontSize, 8, 72)) {
        root.style.setProperty('--font-size-setlist', setlistFontSize + 'px');
      }

      const showArtistParam = params.get('showArtist');
      if (showArtistParam !== null) {
        showArtist = showArtistParam === 'true';
        updateArtistVisibility();
      }

      const setlistEnabledParam = params.get('setlistEnabled');
      if (setlistEnabledParam !== null) {
        setlistEnabled = setlistEnabledParam === 'true';
        updateVisibility();
      }
    }

    function applyLayout(layout) {
      const root = document.getElementById('overlay-root');
      VALID_LAYOUTS.forEach(l => root.classList.remove(`layout-${l}`));
      root.classList.add(`layout-${layout}`);
      currentLayout = layout;
    }

    function updateVisibility() {
      const commentArea = document.getElementById('comment-area');
      const setlistArea = document.getElementById('setlist-area');
      commentArea.classList.toggle('hidden', !commentEnabled);
      setlistArea.classList.toggle('hidden', !setlistEnabled);
    }

    function updateAvatarVisibility() {
      document.querySelectorAll('.avatar').forEach(avatar => {
        avatar.style.display = showAvatar ? 'block' : 'none';
      });
    }

    function updateArtistVisibility() {
      document.querySelectorAll('.song-artist').forEach(artist => {
        artist.style.display = showArtist ? 'block' : 'none';
      });
    }

    // ===== WebSocket設定更新 =====
    function applySettingsUpdate(settings) {
      const root = document.documentElement;

      if (settings.layout && VALID_LAYOUTS.includes(settings.layout)) {
        applyLayout(settings.layout);
      }

      if (settings.primaryColor && isValidHexColor(settings.primaryColor)) {
        root.style.setProperty('--primary-color', settings.primaryColor);
      }

      const sanitizedFont = sanitizeFontFamily(settings.fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      if (settings.comment) {
        if (settings.comment.fontSize && isValidNumber(settings.comment.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-message', settings.comment.fontSize + 'px');
        }
        if (settings.comment.showAvatar !== undefined) {
          showAvatar = settings.comment.showAvatar;
          updateAvatarVisibility();
        }
        if (settings.comment.enabled !== undefined) {
          commentEnabled = settings.comment.enabled;
          updateVisibility();
        }
      }

      if (settings.setlist) {
        if (settings.setlist.fontSize && isValidNumber(settings.setlist.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-setlist', settings.setlist.fontSize + 'px');
        }
        if (settings.setlist.showArtist !== undefined) {
          showArtist = settings.setlist.showArtist;
          updateArtistVisibility();
        }
        if (settings.setlist.enabled !== undefined) {
          setlistEnabled = settings.setlist.enabled;
          updateVisibility();
        }
      }
    }

    // ===== コメント機能 =====
    function trimOverflowingComments() {
      const container = document.getElementById('comment-container');
      const area = document.getElementById('comment-area');
      const areaRect = area.getBoundingClientRect();
      const comments = Array.from(container.querySelectorAll('.comment:not(.removing)'));

      comments.forEach(comment => {
        const rect = comment.getBoundingClientRect();
        if (rect.top < areaRect.top - 10) {
          removeCommentWithAnimation(comment);
        }
      });
    }

    // コメントキュー初期化
    const commentQueue = new CommentQueueManager({
      onAddComment: (comment) => {
        const container = document.getElementById('comment-container');
        if (document.querySelector(`[data-id="${CSS.escape(comment.id)}"]`)) return;

        const el = createCommentElement(comment, showAvatar);
        container.appendChild(el);

        requestAnimationFrame(() => {
          trimOverflowingComments();
        });
      }
    });

    // ===== セットリスト機能 =====
    let currentSetlist = { songs: [], currentIndex: -1 };

    // セットリスト要素のキャッシュ
    const setlistElements = {
      prevEl: document.getElementById('song-prev'),
      currentEl: document.getElementById('song-current'),
      nextEl: document.getElementById('song-next')
    };

    function updateSetlist(data) {
      currentSetlist = data;
      updateSetlistDisplay(data, setlistElements, updateArtistVisibility);
    }

    // ===== 設定フェッチャー =====
    const settingsFetcher = new SettingsFetcher({
      apiBaseUrl: API_BASE_URL,
      timeout: SETTINGS_FETCH_TIMEOUT,
      onSettingsApply: (settings) => {
        applySettingsUpdate(settings);
        applyUrlSettings();
      }
    });

    // ===== WebSocket接続マネージャー =====
    const wsManager = new WebSocketManager({
      url: WS_URL,
      onOpen: () => {
        if (!settingsFetcher.hasFetched()) {
          settingsFetcher.fetchAndApply();
        }
        fetchLatestSetlist(API_BASE_URL, updateSetlist);
      },
      onMessage: (data) => {
        switch (data.type) {
          case 'comment:add':
            // instant=trueなら即時表示（gRPC/InnerTube）、falseならバッファリング（公式APIポーリング）
            if (data.instant) {
              commentQueue.addInstant(data.payload);
            } else {
              commentQueue.queue(data.payload);
            }
            break;
          case 'comment:remove':
            const el = document.querySelector(`[data-id="${CSS.escape(data.payload?.id)}"]`);
            if (el) removeCommentWithAnimation(el);
            break;
          case 'setlist:update':
            updateSetlist({
              songs: data.payload.songs.map(s => ({ title: s.title, artist: s.artist })),
              currentIndex: data.payload.currentIndex
            });
            break;
          case 'settings:update':
            settingsFetcher.incrementVersion();
            applySettingsUpdate(data.payload);
            applyUrlSettings();
            break;
        }
      }
    });

    // ===== ウィンドウリサイズ =====
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        trimOverflowingComments();
      }, 100);
    });

    // ===== 初期化 =====
    applyUrlSettings();
    settingsFetcher.fetchAndApply();
    wsManager.connect();
  </script>
</body>

</html>
