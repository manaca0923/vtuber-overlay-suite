<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comment Overlay</title>
  <style>
    :root {
      --primary-color: #6366f1;
      --background-color: transparent;
      --text-color: #ffffff;
      --text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      --avatar-size: 48px;
      --font-size-name: 14px;
      --font-size-message: 16px;
      --comment-gap: 8px;
      --max-comments: 30;
      --animation-duration: 0.3s;
      --animation-easing: ease-out;
      --font-family: 'Yu Gothic', 'Meiryo', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--background-color);
      font-family: var(--font-family);
      color: var(--text-color);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #comment-container {
      display: flex;
      flex-direction: column;
      gap: var(--comment-gap);
      padding: 16px;
      position: absolute;
      max-width: 100%;
      max-height: 100%;
      overflow: hidden;
    }

    /* 表示位置のスタイル */
    #comment-container.position-top-left { top: 0; left: 0; }
    #comment-container.position-top-right { top: 0; right: 0; }
    #comment-container.position-bottom-left { bottom: 0; left: 0; }
    #comment-container.position-bottom-right { bottom: 0; right: 0; }

    /* bottom配置時はコメントを下から上に積む */
    #comment-container.position-bottom-left,
    #comment-container.position-bottom-right {
      flex-direction: column-reverse;
    }

    .comment {
      display: flex;
      gap: 12px;
      padding: 12px;
      background: rgba(0, 0, 0, 0.6);
      border-radius: 8px;
      backdrop-filter: blur(8px);
      animation: comment-enter var(--animation-duration) var(--animation-easing);
    }

    .comment.no-animation {
      animation: none;
    }

    .comment.removing {
      animation: comment-exit var(--animation-duration) var(--animation-easing);
    }

    .comment.superchat {
      background: linear-gradient(135deg, var(--sc-color, #ff0000) 0%, rgba(0, 0, 0, 0.8) 100%);
      border: 2px solid var(--sc-color, #ff0000);
    }

    .comment.supersticker {
      background: linear-gradient(135deg, #f59e0b 0%, rgba(0, 0, 0, 0.8) 100%);
      border: 2px solid #f59e0b;
    }

    .comment.membership {
      background: linear-gradient(135deg, #10b981 0%, rgba(0, 0, 0, 0.8) 100%);
      border: 2px solid #10b981;
    }

    .comment.membershipgift {
      background: linear-gradient(135deg, #8b5cf6 0%, rgba(0, 0, 0, 0.8) 100%);
      border: 2px solid #8b5cf6;
    }

    .avatar {
      width: var(--avatar-size);
      height: var(--avatar-size);
      border-radius: 50%;
      flex-shrink: 0;
    }

    .content {
      flex: 1;
      min-width: 0;
    }

    .header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .name {
      font-size: var(--font-size-name);
      font-weight: bold;
      text-shadow: var(--text-shadow);
    }

    .badge {
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: bold;
      text-transform: uppercase;
    }

    .badge-owner {
      background: #fbbf24;
      color: #000;
    }

    .badge-moderator {
      background: #3b82f6;
      color: #fff;
    }

    .badge-member {
      background: #10b981;
      color: #fff;
    }

    .message {
      font-size: var(--font-size-message);
      word-wrap: break-word;
      text-shadow: var(--text-shadow);
    }

    .amount {
      font-size: var(--font-size-name);
      font-weight: bold;
      color: #fbbf24;
    }

    @keyframes comment-enter {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes comment-exit {
      from {
        opacity: 1;
        transform: translateY(0);
      }
      to {
        opacity: 0;
        transform: translateY(-20px);
      }
    }

    ::-webkit-scrollbar {
      display: none;
    }
  </style>
</head>
<body>
  <div id="comment-container"></div>

  <script>
    // 設定状態（動的に変更可能）
    let maxComments = 30;
    let showAvatar = true;
    let overlayEnabled = true;
    let overlayPosition = 'bottom-right';

    const WS_URL = 'ws://localhost:19801/ws';
    const API_BASE_URL = 'http://localhost:19800/api';

    // 有効なポジション値
    const VALID_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    let ws = null;
    let reconnectDelay = 1000;

    // バリデーション関数
    function isValidHexColor(color) {
      return typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(color);
    }

    function isValidNumber(value, min, max) {
      const num = parseInt(value, 10);
      return !isNaN(num) && num >= min && num <= max;
    }

    // fontFamilyのサニタイズ（XSS対策）
    function sanitizeFontFamily(fontFamily) {
      if (typeof fontFamily !== 'string' || fontFamily.length === 0 || fontFamily.length > 200) {
        return null;
      }
      // 危険な文字を除去
      return fontFamily.replace(/[<>"'`\;{}]/g, '');
    }

    // URLパラメータから設定を適用
    function applyUrlSettings() {
      const params = new URLSearchParams(window.location.search);
      const root = document.documentElement;

      const primaryColor = params.get('primaryColor');
      if (primaryColor && isValidHexColor(primaryColor)) {
        root.style.setProperty('--primary-color', primaryColor);
      }
      const fontSize = params.get('fontSize');
      if (fontSize && isValidNumber(fontSize, 8, 72)) {
        root.style.setProperty('--font-size-message', fontSize + 'px');
      }
      const avatarSize = params.get('avatarSize');
      if (avatarSize && isValidNumber(avatarSize, 16, 128)) {
        root.style.setProperty('--avatar-size', avatarSize + 'px');
      }
      // maxCount
      const maxCount = params.get('maxCount');
      let maxCountChanged = false;
      if (maxCount && isValidNumber(maxCount, 5, 30)) {
        maxComments = parseInt(maxCount, 10);
        maxCountChanged = true;
      }
      // showAvatar
      const showAvatarParam = params.get('showAvatar');
      let showAvatarChanged = false;
      if (showAvatarParam !== null) {
        showAvatar = showAvatarParam === 'true';
        showAvatarChanged = true;
      }
      // borderRadius
      const borderRadius = params.get('borderRadius');
      if (borderRadius && isValidNumber(borderRadius, 0, 32)) {
        root.style.setProperty('--border-radius', borderRadius + 'px');
        updateCommentBorderRadius(parseInt(borderRadius, 10));
      }
      // position
      const position = params.get('position');
      if (position && VALID_POSITIONS.includes(position)) {
        overlayPosition = position;
        updateContainerPosition();
      }
      // enabled
      const enabled = params.get('enabled');
      if (enabled !== null) {
        overlayEnabled = enabled === 'true';
        updateOverlayVisibility();
      }
      // fontFamily
      const fontFamily = params.get('fontFamily');
      const sanitizedFont = sanitizeFontFamily(fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      // 既存DOMの更新（設定適用後に必要）
      if (showAvatarChanged) {
        updateAvatarVisibility();
      }
      if (maxCountChanged) {
        trimOldComments();
      }
    }

    // 角丸を更新
    function updateCommentBorderRadius(radius) {
      const style = document.querySelector('#dynamic-styles') || document.createElement('style');
      style.id = 'dynamic-styles';
      style.textContent = `.comment { border-radius: ${radius}px !important; }`;
      if (!style.parentNode) {
        document.head.appendChild(style);
      }
    }

    // コンテナの表示位置を更新
    function updateContainerPosition() {
      const container = document.getElementById('comment-container');
      // 既存のpositionクラスを削除
      VALID_POSITIONS.forEach(pos => {
        container.classList.remove(`position-${pos}`);
      });
      // 新しいpositionクラスを追加
      container.classList.add(`position-${overlayPosition}`);
    }

    // オーバーレイの表示/非表示を更新
    function updateOverlayVisibility() {
      const container = document.getElementById('comment-container');
      container.style.display = overlayEnabled ? 'flex' : 'none';
    }

    // WebSocket経由の設定更新を適用
    function applySettingsUpdate(settings) {
      const root = document.documentElement;

      // 共通設定
      if (settings.primaryColor && isValidHexColor(settings.primaryColor)) {
        root.style.setProperty('--primary-color', settings.primaryColor);
      }
      if (settings.borderRadius !== undefined && isValidNumber(settings.borderRadius, 0, 32)) {
        updateCommentBorderRadius(settings.borderRadius);
      }
      const sanitizedFont = sanitizeFontFamily(settings.fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      // コメント設定（新しいペイロード構造）
      if (settings.comment) {
        if (settings.comment.fontSize && isValidNumber(settings.comment.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-message', settings.comment.fontSize + 'px');
        }
        if (settings.comment.maxCount && isValidNumber(settings.comment.maxCount, 5, 50)) {
          maxComments = settings.comment.maxCount;
          // 現在のコメント数が新しい上限を超えている場合、古いコメントを削除
          trimOldComments();
        }
        if (settings.comment.showAvatar !== undefined) {
          showAvatar = settings.comment.showAvatar;
          updateAvatarVisibility();
        }
        if (settings.comment.enabled !== undefined) {
          overlayEnabled = settings.comment.enabled;
          updateOverlayVisibility();
        }
        if (settings.comment.position && VALID_POSITIONS.includes(settings.comment.position)) {
          overlayPosition = settings.comment.position;
          updateContainerPosition();
        }
      }
    }

    // 古いコメントを削除して上限に収める
    function trimOldComments() {
      const container = document.getElementById('comment-container');
      while (container.children.length > maxComments) {
        container.firstChild.remove();
      }
    }

    // アバター表示/非表示を更新
    function updateAvatarVisibility() {
      const avatars = document.querySelectorAll('.avatar');
      avatars.forEach(avatar => {
        avatar.style.display = showAvatar ? 'block' : 'none';
      });
    }

    // 初期化時にURLパラメータを適用
    applyUrlSettings();
    // デフォルトのポジションを適用
    updateContainerPosition();

    // 設定取得成功フラグ（fetch失敗時のリカバリー用）
    let settingsFetchedSuccessfully = false;

    // HTTP APIから初期設定を取得して適用（タイムアウト付き）
    async function fetchAndApplySettings() {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000); // 3秒タイムアウト

        const response = await fetch(`${API_BASE_URL}/overlay/settings`, {
          signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (response.ok) {
          const settings = await response.json();
          console.log('Fetched overlay settings:', settings);
          applySettingsUpdate(settings);
          // URLパラメータを再適用（URL優先）
          applyUrlSettings();
          settingsFetchedSuccessfully = true;
        }
      } catch (e) {
        if (e.name === 'AbortError') {
          console.log('Settings API timeout, using defaults');
        } else {
          console.log('Settings API not available, using defaults');
        }
        // 失敗時はフラグをfalseのままにして、ws.onopenでリトライ可能にする
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('WebSocket connected');
        reconnectDelay = 1000;
        // 設定取得が未成功の場合は再取得（初回fetch失敗時または再接続時）
        if (!settingsFetchedSuccessfully) {
          fetchAndApplySettings();
        }
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'comment:add') {
            addComment(data.payload);
          } else if (data.type === 'settings:update') {
            applySettingsUpdate(data.payload);
            // URLパラメータを再適用（URL優先を維持）
            applyUrlSettings();
          }
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

      ws.onclose = () => {
        console.log('WebSocket closed, reconnecting...');
        setTimeout(() => {
          reconnectDelay = Math.min(reconnectDelay * 2, 30000);
          connectWebSocket();
        }, reconnectDelay);
      };
    }

    function addComment(comment) {
      const container = document.getElementById('comment-container');

      // comment.idがundefined/nullの場合はスキップ
      if (!comment || !comment.id) {
        console.warn('Invalid comment: missing id', comment);
        return;
      }

      // 重複チェック（再接続時のキャッシュ復元で重要）
      if (document.querySelector(`[data-id="${CSS.escape(comment.id)}"]`)) {
        return; // 既に表示済み
      }

      const el = createCommentElement(comment);
      container.appendChild(el);

      // 古いコメントを削除（maxCommentsは設定で動的に変更可能）
      while (container.children.length > maxComments) {
        container.firstChild.remove();
      }
    }

    function createCommentElement(comment) {
      const div = document.createElement('div');
      div.className = 'comment';
      div.dataset.id = comment.id;

      // messageTypeはタグ付きenum: { type: "text" | "superChat" | ... }
      const messageType = comment.messageType?.type;
      if (messageType === 'superChat') {
        div.classList.add('superchat');
      } else if (messageType === 'superSticker') {
        div.classList.add('supersticker');
      } else if (messageType === 'membership') {
        div.classList.add('membership');
      } else if (messageType === 'membershipGift') {
        div.classList.add('membershipgift');
      }

      const avatar = document.createElement('img');
      avatar.className = 'avatar';
      avatar.src = comment.authorImageUrl;
      avatar.alt = comment.authorName;
      // showAvatar設定を反映
      if (!showAvatar) {
        avatar.style.display = 'none';
      }

      const content = document.createElement('div');
      content.className = 'content';

      const header = document.createElement('div');
      header.className = 'header';

      const name = document.createElement('span');
      name.className = 'name';
      name.textContent = comment.authorName;
      header.appendChild(name);

      if (comment.isOwner) {
        const badge = document.createElement('span');
        badge.className = 'badge badge-owner';
        badge.textContent = 'Owner';
        header.appendChild(badge);
      }

      if (comment.isModerator) {
        const badge = document.createElement('span');
        badge.className = 'badge badge-moderator';
        badge.textContent = 'Mod';
        header.appendChild(badge);
      }

      if (comment.isMember) {
        const badge = document.createElement('span');
        badge.className = 'badge badge-member';
        badge.textContent = 'Member';
        header.appendChild(badge);
      }

      // スーパーチャットの金額表示
      if (messageType === 'superChat' && comment.messageType.amount) {
        const amount = document.createElement('span');
        amount.className = 'amount';
        amount.textContent = comment.messageType.amount;
        header.appendChild(amount);
      }

      // スーパーステッカーのバッジ
      if (messageType === 'superSticker') {
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.style.background = '#f59e0b';
        badge.style.color = '#000';
        badge.textContent = 'Sticker';
        header.appendChild(badge);
      }

      // メンバーシップのバッジ（レベル表示対応）
      if (messageType === 'membership') {
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.style.background = '#10b981';
        badge.style.color = '#fff';
        // levelフィールドがあれば表示、なければデフォルト
        const level = comment.messageType.level || 'New Member';
        badge.textContent = level;
        header.appendChild(badge);
      }

      // メンバーシップギフトのバッジ
      if (messageType === 'membershipGift' && comment.messageType.count) {
        const badge = document.createElement('span');
        badge.className = 'badge';
        badge.style.background = '#8b5cf6';
        badge.style.color = '#fff';
        badge.textContent = `Gift x${comment.messageType.count}`;
        header.appendChild(badge);
      }

      const message = document.createElement('div');
      message.className = 'message';
      message.textContent = comment.message;

      content.appendChild(header);
      content.appendChild(message);

      div.appendChild(avatar);
      div.appendChild(content);

      return div;
    }

    // 初期化: 設定取得とWebSocket接続を並列実行（HTTP遅延でもWS接続を遅らせない）
    fetchAndApplySettings();
    connectWebSocket();
  </script>
</body>
</html>
