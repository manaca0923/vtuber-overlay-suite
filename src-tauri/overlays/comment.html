<!DOCTYPE html>
<html lang="ja">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comment Overlay</title>
  <!-- 共通スタイル -->
  <link rel="stylesheet" href="shared/overlay-common.css">
  <style>
    /* comment.html固有のスタイル */
    body {
      width: 100vw;
      height: 100vh;
    }

    #comment-container {
      display: flex;
      flex-direction: column;
      justify-content: flex-end;
      gap: var(--comment-gap);
      padding: 16px;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    /* 表示位置のスタイル */
    #comment-container.position-top-left,
    #comment-container.position-top-right {
      flex-direction: column;
      justify-content: flex-start;
    }

    #comment-container.position-bottom-left,
    #comment-container.position-bottom-right {
      flex-direction: column;
      justify-content: flex-end;
    }

    #comment-container.position-top-right,
    #comment-container.position-bottom-right {
      align-items: flex-end;
    }

    #comment-container.position-top-left,
    #comment-container.position-bottom-left {
      align-items: stretch;
    }

    /* comment.html固有: コメント幅 */
    .comment {
      width: calc(100% - 32px);
      align-self: stretch;
      box-sizing: border-box;
    }
  </style>
</head>

<body>
  <div id="comment-container"></div>

  <!-- 共通スクリプト -->
  <script src="shared/comment-renderer.js?v=2"></script>
  <script>
    // 共通モジュールから関数を取得
    const {
      isValidHexColor,
      isValidNumber,
      sanitizeFontFamily,
      createCommentElement,
      removeCommentWithAnimation,
      CommentQueueManager
    } = window.CommentRenderer;

    // 設定状態
    let showAvatar = true;
    let overlayEnabled = true;
    let overlayPosition = 'bottom-left';

    const WS_URL = 'ws://localhost:19801/ws';
    const API_BASE_URL = 'http://localhost:19800/api';

    const VALID_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];
    let ws = null;
    let reconnectDelay = 1000;

    // URLパラメータから設定を適用
    function applyUrlSettings() {
      const params = new URLSearchParams(window.location.search);
      const root = document.documentElement;

      const primaryColor = params.get('primaryColor');
      if (primaryColor && isValidHexColor(primaryColor)) {
        root.style.setProperty('--primary-color', primaryColor);
      }
      const fontSize = params.get('fontSize');
      if (fontSize && isValidNumber(fontSize, 8, 72)) {
        root.style.setProperty('--font-size-message', fontSize + 'px');
      }
      const avatarSize = params.get('avatarSize');
      if (avatarSize && isValidNumber(avatarSize, 16, 128)) {
        root.style.setProperty('--avatar-size', avatarSize + 'px');
      }
      const showAvatarParam = params.get('showAvatar');
      let showAvatarChanged = false;
      if (showAvatarParam !== null) {
        showAvatar = showAvatarParam === 'true';
        showAvatarChanged = true;
      }
      const borderRadius = params.get('borderRadius');
      if (borderRadius && isValidNumber(borderRadius, 0, 32)) {
        root.style.setProperty('--border-radius', borderRadius + 'px');
        updateCommentBorderRadius(parseInt(borderRadius, 10));
      }
      const position = params.get('position');
      if (position && VALID_POSITIONS.includes(position)) {
        overlayPosition = position;
        updateContainerPosition();
      }
      const enabled = params.get('enabled');
      if (enabled !== null) {
        overlayEnabled = enabled === 'true';
        updateOverlayVisibility();
      }
      const fontFamily = params.get('fontFamily');
      const sanitizedFont = sanitizeFontFamily(fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      if (showAvatarChanged) {
        updateAvatarVisibility();
      }
    }

    function updateCommentBorderRadius(radius) {
      const style = document.querySelector('#dynamic-styles') || document.createElement('style');
      style.id = 'dynamic-styles';
      style.textContent = `.comment { border-radius: ${radius}px !important; }`;
      if (!style.parentNode) {
        document.head.appendChild(style);
      }
    }

    function updateContainerPosition() {
      const container = document.getElementById('comment-container');
      VALID_POSITIONS.forEach(pos => {
        container.classList.remove(`position-${pos}`);
      });
      container.classList.add(`position-${overlayPosition}`);

      if (overlayPosition.startsWith('bottom-')) {
        container.style.flexDirection = 'column';
        container.style.justifyContent = 'flex-end';
      } else {
        container.style.flexDirection = 'column';
        container.style.justifyContent = 'flex-start';
      }
    }

    function updateOverlayVisibility() {
      const container = document.getElementById('comment-container');
      container.style.display = overlayEnabled ? 'flex' : 'none';
    }

    function applySettingsUpdate(settings) {
      const root = document.documentElement;

      if (settings.primaryColor && isValidHexColor(settings.primaryColor)) {
        root.style.setProperty('--primary-color', settings.primaryColor);
      }
      if (settings.borderRadius !== undefined && isValidNumber(settings.borderRadius, 0, 32)) {
        updateCommentBorderRadius(settings.borderRadius);
      }
      const sanitizedFont = sanitizeFontFamily(settings.fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      if (settings.comment) {
        if (settings.comment.fontSize && isValidNumber(settings.comment.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-message', settings.comment.fontSize + 'px');
          trimOverflowingComments();
        }
        if (settings.comment.showAvatar !== undefined) {
          showAvatar = settings.comment.showAvatar;
          updateAvatarVisibility();
        }
        if (settings.comment.enabled !== undefined) {
          overlayEnabled = settings.comment.enabled;
          updateOverlayVisibility();
        }
        if (settings.comment.position && VALID_POSITIONS.includes(settings.comment.position)) {
          overlayPosition = settings.comment.position;
          updateContainerPosition();
        }
      }
    }

    function trimOverflowingComments() {
      const container = document.getElementById('comment-container');
      const containerRect = container.getBoundingClientRect();
      const comments = Array.from(container.querySelectorAll('.comment:not(.removing)'));
      const isBottomPosition = overlayPosition.startsWith('bottom-');

      comments.forEach(comment => {
        const rect = comment.getBoundingClientRect();
        if (isBottomPosition) {
          if (rect.top < containerRect.top - 10) {
            removeCommentWithAnimation(comment);
          }
        } else {
          if (rect.bottom > containerRect.bottom + 10) {
            removeCommentWithAnimation(comment);
          }
        }
      });
    }

    function updateAvatarVisibility() {
      const avatars = document.querySelectorAll('.avatar');
      avatars.forEach(avatar => {
        avatar.style.display = showAvatar ? 'block' : 'none';
      });
    }

    // 初期化時にURLパラメータを適用
    applyUrlSettings();
    updateContainerPosition();

    // 設定取得のバージョン管理
    let settingsVersion = 0;
    let fetchInFlight = false;
    let retryPending = false;
    let settingsFetchSucceeded = false;
    let isFirstConnection = true;

    async function fetchAndApplySettings() {
      if (fetchInFlight) {
        retryPending = true;
        return;
      }
      fetchInFlight = true;
      retryPending = false;
      const requestVersion = settingsVersion;

      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 3000);

        const response = await fetch(`${API_BASE_URL}/overlay/settings`, {
          signal: controller.signal
        });
        clearTimeout(timeoutId);

        if (response.ok) {
          const settings = await response.json();
          if (settingsVersion > requestVersion) {
            // 新しいWS設定が適用済みのためスキップ
            return;
          }
          applySettingsUpdate(settings);
          applyUrlSettings();
          settingsFetchSucceeded = true;
        }
      } catch (e) {
        // 設定API未起動時はデフォルト設定を使用（エラーログ不要）
      } finally {
        fetchInFlight = false;
        if (retryPending && !settingsFetchSucceeded) {
          retryPending = false;
          fetchAndApplySettings();
        }
      }
    }

    // コメントキュー初期化
    const commentQueue = new CommentQueueManager({
      onAddComment: (comment) => {
        const container = document.getElementById('comment-container');
        if (document.querySelector(`[data-id="${CSS.escape(comment.id)}"]`)) {
          return;
        }
        const el = createCommentElement(comment, showAvatar);
        container.appendChild(el);
        requestAnimationFrame(() => {
          trimOverflowingComments();
        });
      }
    });

    function removeComment(commentId) {
      if (!commentId) return;
      const el = document.querySelector(`[data-id="${CSS.escape(commentId)}"]`);
      if (el) {
        removeCommentWithAnimation(el);
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        reconnectDelay = 1000;
        if (!isFirstConnection || !settingsFetchSucceeded) {
          fetchAndApplySettings();
        }
        isFirstConnection = false;
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          if (data.type === 'comment:add') {
            // instant=trueなら即時表示（gRPC/InnerTube）、falseならバッファリング（公式APIポーリング）
            if (data.instant) {
              commentQueue.addInstant(data.payload);
            } else {
              // bufferIntervalMs が指定されていればバッファ間隔を更新
              commentQueue.queue(data.payload, data.bufferIntervalMs);
            }
          } else if (data.type === 'comment:remove') {
            removeComment(data.payload?.id);
          } else if (data.type === 'settings:update') {
            settingsVersion++;
            applySettingsUpdate(data.payload);
            applyUrlSettings();
          }
        } catch (e) {
          // JSONパースエラー（通常発生しない）
        }
      };

      ws.onerror = () => {
        // 接続エラー時は自動再接続（oncloseで処理）
      };

      ws.onclose = () => {
        setTimeout(() => {
          reconnectDelay = Math.min(reconnectDelay * 2, 30000);
          connectWebSocket();
        }, reconnectDelay);
      };
    }

    // ウィンドウリサイズ時に画面外コメントを削除
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        trimOverflowingComments();
      }, 100);
    });

    // 初期化
    fetchAndApplySettings();
    connectWebSocket();
  </script>
</body>

</html>
