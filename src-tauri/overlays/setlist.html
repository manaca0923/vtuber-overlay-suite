<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Setlist Overlay</title>
  <style>
    :root {
      --primary-color: #6366f1;
      --current-bg: rgba(99, 102, 241, 0.8);
      --other-bg: rgba(0, 0, 0, 0.5);
      --text-color: #ffffff;
      --text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
      --font-size-title: 24px;
      --font-size-artist: 14px;
      --transition-duration: 0.5s;
      --font-family: 'Yu Gothic', 'Meiryo', sans-serif;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: transparent;
      font-family: var(--font-family);
      color: var(--text-color);
      overflow: hidden;
      width: 100vw;
      height: 100vh;
    }

    #setlist-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 16px;
      position: absolute;
    }

    /* 表示位置のスタイル */
    #setlist-container.position-top { top: 0; left: 0; right: 0; }
    #setlist-container.position-bottom { bottom: 0; left: 0; right: 0; }
    #setlist-container.position-left { top: 0; left: 0; bottom: 0; width: auto; }
    #setlist-container.position-right { top: 0; right: 0; bottom: 0; width: auto; }

    .song {
      padding: 16px 20px;
      border-radius: 8px;
      backdrop-filter: blur(8px);
      transition: all var(--transition-duration) ease-out;
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .song.previous,
    .song.next {
      background: var(--other-bg);
      opacity: 0.6;
      font-size: 14px;
    }

    .song.current {
      background: var(--current-bg);
      border: 2px solid var(--primary-color);
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.5);
      font-size: 18px;
    }

    .song.entering {
      animation: slide-up var(--transition-duration) ease-out;
    }

    .indicator {
      font-size: 24px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .title-wrapper {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      position: relative;
    }

    .title {
      font-size: var(--font-size-title);
      font-weight: bold;
      text-shadow: var(--text-shadow);
      white-space: nowrap;
      display: inline-block;
    }

    /* 前後の曲は省略表示 */
    .song.previous .title,
    .song.next .title {
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
    }

    /* 現在の曲のマーキーアニメーション */
    .song.current .title.marquee {
      animation: marquee var(--marquee-duration, 10s) linear infinite;
      animation-delay: 3s;
    }

    @keyframes marquee {
      0%, 15% {
        transform: translateX(0);
        opacity: 1;
      }
      20% {
        transform: translateX(0);
        opacity: 1;
      }
      75%, 90% {
        transform: translateX(var(--marquee-distance, -100px));
        opacity: 1;
      }
      95% {
        transform: translateX(var(--marquee-distance, -100px));
        opacity: 0;
      }
      97% {
        transform: translateX(0);
        opacity: 0;
      }
      100% {
        transform: translateX(0);
        opacity: 1;
      }
    }

    .artist {
      font-size: var(--font-size-artist);
      opacity: 0.8;
      text-shadow: var(--text-shadow);
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    @keyframes slide-up {
      from {
        transform: translateY(100%);
        opacity: 0;
      }
      to {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes pulse {
      0%, 100% {
        opacity: 1;
      }
      50% {
        opacity: 0.5;
      }
    }

    ::-webkit-scrollbar {
      display: none;
    }
  </style>
</head>
<body>
  <div id="setlist-container">
    <div class="song previous" id="prev-song">
      <div class="title-wrapper">
        <span class="title">-</span>
      </div>
    </div>
    <div class="song current" id="current-song">
      <span class="indicator">♪</span>
      <div class="title-wrapper">
        <span class="title">配信準備中...</span>
      </div>
      <span class="artist"></span>
    </div>
    <div class="song next" id="next-song">
      <div class="title-wrapper">
        <span class="title">-</span>
      </div>
    </div>
  </div>

  <script>
    const WS_URL = 'ws://localhost:19801/ws';
    const API_BASE_URL = 'http://localhost:19800/api';
    let ws = null;
    let reconnectDelay = 1000;
    const maxDelay = 30000;

    // 設定状態（動的に変更可能）
    let showArtist = true;
    let overlayEnabled = true;
    let overlayPosition = 'bottom';

    // 有効なポジション値
    const VALID_POSITIONS = ['top', 'bottom', 'left', 'right'];

    // バリデーション関数
    function isValidHexColor(color) {
      return typeof color === 'string' && /^#[0-9A-Fa-f]{6}$/.test(color);
    }

    function isValidNumber(value, min, max) {
      const num = parseInt(value, 10);
      return !isNaN(num) && num >= min && num <= max;
    }

    // fontFamilyのサニタイズ（XSS対策）
    function sanitizeFontFamily(fontFamily) {
      if (typeof fontFamily !== 'string' || fontFamily.length === 0 || fontFamily.length > 200) {
        return null;
      }
      // 危険な文字を除去
      return fontFamily.replace(/[<>"'`\;{}]/g, '');
    }

    // 16進カラーコードをRGB値にパース
    function parseHexColor(color) {
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      return { r, g, b };
    }

    // URLパラメータから設定を適用
    function applyUrlSettings() {
      const params = new URLSearchParams(window.location.search);
      const root = document.documentElement;

      const primaryColor = params.get('primaryColor');
      if (primaryColor && isValidHexColor(primaryColor)) {
        root.style.setProperty('--primary-color', primaryColor);
        // current-bgも更新（プライマリカラーベースで透明度を適用）
        const { r, g, b } = parseHexColor(primaryColor);
        root.style.setProperty('--current-bg', `rgba(${r}, ${g}, ${b}, 0.8)`);
      }
      const fontSize = params.get('fontSize');
      if (fontSize && isValidNumber(fontSize, 8, 72)) {
        root.style.setProperty('--font-size-title', fontSize + 'px');
      }
      // showArtist
      const showArtistParam = params.get('showArtist');
      if (showArtistParam !== null) {
        showArtist = showArtistParam === 'true';
        updateArtistVisibility();
      }
      // borderRadius
      const borderRadius = params.get('borderRadius');
      if (borderRadius && isValidNumber(borderRadius, 0, 32)) {
        updateSongBorderRadius(parseInt(borderRadius, 10));
      }
      // position
      const position = params.get('position');
      if (position && VALID_POSITIONS.includes(position)) {
        overlayPosition = position;
        updateContainerPosition();
      }
      // enabled
      const enabled = params.get('enabled');
      if (enabled !== null) {
        overlayEnabled = enabled === 'true';
        updateOverlayVisibility();
      }
      // fontFamily
      const fontFamily = params.get('fontFamily');
      const sanitizedFont = sanitizeFontFamily(fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }
    }

    // 角丸を更新
    function updateSongBorderRadius(radius) {
      const style = document.querySelector('#dynamic-styles') || document.createElement('style');
      style.id = 'dynamic-styles';
      style.textContent = `.song { border-radius: ${radius}px !important; }`;
      if (!style.parentNode) {
        document.head.appendChild(style);
      }
    }

    // アーティスト表示/非表示を更新
    function updateArtistVisibility() {
      const artists = document.querySelectorAll('.artist');
      artists.forEach(artist => {
        artist.style.display = showArtist ? 'block' : 'none';
      });
    }

    // コンテナの表示位置を更新
    function updateContainerPosition() {
      const container = document.getElementById('setlist-container');
      // 既存のpositionクラスを削除
      VALID_POSITIONS.forEach(pos => {
        container.classList.remove(`position-${pos}`);
      });
      // 新しいpositionクラスを追加
      container.classList.add(`position-${overlayPosition}`);
    }

    // オーバーレイの表示/非表示を更新
    function updateOverlayVisibility() {
      const container = document.getElementById('setlist-container');
      container.style.display = overlayEnabled ? 'flex' : 'none';
    }

    // WebSocket経由の設定更新を適用
    function applySettingsUpdate(settings) {
      const root = document.documentElement;

      // 共通設定
      if (settings.primaryColor && isValidHexColor(settings.primaryColor)) {
        root.style.setProperty('--primary-color', settings.primaryColor);
        const { r, g, b } = parseHexColor(settings.primaryColor);
        root.style.setProperty('--current-bg', `rgba(${r}, ${g}, ${b}, 0.8)`);
      }
      if (settings.borderRadius !== undefined && isValidNumber(settings.borderRadius, 0, 32)) {
        updateSongBorderRadius(settings.borderRadius);
      }
      const sanitizedFont = sanitizeFontFamily(settings.fontFamily);
      if (sanitizedFont) {
        root.style.setProperty('--font-family', sanitizedFont);
      }

      // セットリスト設定（新しいペイロード構造）
      if (settings.setlist) {
        if (settings.setlist.fontSize && isValidNumber(settings.setlist.fontSize, 8, 72)) {
          root.style.setProperty('--font-size-title', settings.setlist.fontSize + 'px');
        }
        if (settings.setlist.showArtist !== undefined) {
          showArtist = settings.setlist.showArtist;
          updateArtistVisibility();
        }
        if (settings.setlist.enabled !== undefined) {
          overlayEnabled = settings.setlist.enabled;
          updateOverlayVisibility();
        }
        if (settings.setlist.position && VALID_POSITIONS.includes(settings.setlist.position)) {
          overlayPosition = settings.setlist.position;
          updateContainerPosition();
        }
      }
    }

    // 初期化時にURLパラメータを適用
    applyUrlSettings();
    // デフォルトのポジションを適用
    updateContainerPosition();

    // HTTP APIから初期設定を取得して適用
    async function fetchAndApplySettings() {
      try {
        const response = await fetch(`${API_BASE_URL}/overlay/settings`);
        if (response.ok) {
          const settings = await response.json();
          console.log('Fetched overlay settings:', settings);
          applySettingsUpdate(settings);
        }
      } catch (e) {
        console.log('Settings API not available, using defaults');
      }
    }

    // URLパラメータからセットリストIDを取得
    function getSetlistIdFromUrl() {
      const params = new URLSearchParams(window.location.search);
      return params.get('setlist_id') || params.get('id');
    }

    // エラーメッセージを表示
    function showError(message) {
      const currentSong = document.getElementById('current-song');
      if (currentSong) {
        currentSong.querySelector('.title').textContent = message;
        currentSong.querySelector('.artist').textContent = '';
      }
    }

    // HTTP APIからセットリストを取得して表示
    async function fetchAndDisplaySetlist() {
      const setlistId = getSetlistIdFromUrl();
      // setlist_idがURLにない場合は最新のセットリストを取得
      const apiUrl = setlistId
        ? `${API_BASE_URL}/setlist/${setlistId}`
        : `${API_BASE_URL}/setlist/latest`;

      try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
          if (response.status === 404) {
            console.log('No setlist found, waiting for WebSocket updates');
            return;
          }
          console.error('Failed to fetch setlist:', response.status);
          showError('セットリストの取得に失敗しました');
          return;
        }
        const data = await response.json();
        console.log('Fetched setlist data:', data);
        updateSetlist(data);
      } catch (e) {
        console.error('Error fetching setlist:', e);
        showError('接続エラーが発生しました');
      }
    }

    function connectWebSocket() {
      ws = new WebSocket(WS_URL);

      ws.onopen = () => {
        console.log('WebSocket connected');
        reconnectDelay = 1000;
        // 接続成功後、HTTP APIで初期データを取得
        fetchAndDisplaySetlist();
        fetchAndApplySettings();
      };

      ws.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          handleMessage(data);
        } catch (e) {
          console.error('Failed to parse message:', e);
        }
      };

      ws.onerror = (error) => {
        console.error('WebSocket error:', error);
      };

      ws.onclose = () => {
        console.log('WebSocket closed. Reconnecting in', reconnectDelay, 'ms');
        setTimeout(() => {
          reconnectDelay = Math.min(reconnectDelay * 2, maxDelay);
          connectWebSocket();
        }, reconnectDelay);
      };
    }

    function handleMessage(data) {
      if (data.type === 'setlist:update') {
        const urlSetlistId = getSetlistIdFromUrl();
        const messageSetlistId = data.payload.setlistId;

        // URLでsetlist_idが指定されている場合は、そのIDとマッチするメッセージのみ処理
        // 指定されていない場合（最新モード）は全てのWS更新を受け入れる
        if (urlSetlistId && messageSetlistId && urlSetlistId !== messageSetlistId) {
          console.log('Ignoring setlist update for different setlist:', messageSetlistId, 'expected:', urlSetlistId);
          return;
        }

        updateSetlist(data.payload);
      } else if (data.type === 'settings:update') {
        applySettingsUpdate(data.payload);
      }
    }

    // マーキー設定の定数
    const MARQUEE_PADDING = 20;      // スクロール時の余白（px）
    const MARQUEE_MIN_DURATION = 8;  // 最小アニメーション時間（秒）
    const MARQUEE_SCROLL_SPEED = 30; // スクロール速度（px/秒）

    // マーキー効果を適用（テキストがコンテナより長い場合のみ）
    function applyMarqueeEffect(titleElement, wrapperElement) {
      // リセット
      titleElement.classList.remove('marquee');
      titleElement.style.removeProperty('--marquee-distance');
      titleElement.style.removeProperty('--marquee-duration');

      // DOMの更新を待つ
      requestAnimationFrame(() => {
        const titleWidth = titleElement.scrollWidth;
        const wrapperWidth = wrapperElement.clientWidth;

        if (titleWidth > wrapperWidth) {
          const overflow = titleWidth - wrapperWidth + MARQUEE_PADDING;
          const duration = Math.max(MARQUEE_MIN_DURATION, overflow / MARQUEE_SCROLL_SPEED);

          titleElement.style.setProperty('--marquee-distance', `-${overflow}px`);
          titleElement.style.setProperty('--marquee-duration', `${duration}s`);
          titleElement.classList.add('marquee');
        }
      });
    }

    function updateSetlist(payload) {
      const { currentIndex, songs } = payload;

      const prevSong = document.getElementById('prev-song');
      const currentSong = document.getElementById('current-song');
      const nextSong = document.getElementById('next-song');

      const currentTitle = currentSong.querySelector('.title');
      const currentWrapper = currentSong.querySelector('.title-wrapper');

      // 曲がない場合
      if (!songs || songs.length === 0) {
        prevSong.style.display = 'none';
        currentTitle.textContent = '曲がありません';
        currentTitle.classList.remove('marquee');
        currentSong.querySelector('.artist').textContent = '';
        nextSong.style.display = 'none';
        return;
      }

      // currentIndex === -1 の場合（曲が選択されていない）
      if (currentIndex < 0 || currentIndex >= songs.length) {
        prevSong.style.display = 'none';
        currentTitle.textContent = '配信準備中...';
        currentTitle.classList.remove('marquee');
        currentSong.querySelector('.artist').textContent = '';
        // 次の曲として最初の曲を表示
        if (songs.length > 0) {
          nextSong.querySelector('.title').textContent = songs[0].title;
          nextSong.style.display = 'flex';
        } else {
          nextSong.style.display = 'none';
        }
        return;
      }

      // 前の曲
      if (currentIndex > 0 && songs[currentIndex - 1]) {
        const song = songs[currentIndex - 1];
        prevSong.querySelector('.title').textContent = song.title;
        prevSong.style.display = 'flex';
      } else {
        prevSong.style.display = 'none';
      }

      // 現在の曲
      const song = songs[currentIndex];
      currentTitle.textContent = song.title;
      currentSong.querySelector('.artist').textContent = song.artist || '';
      currentSong.classList.add('entering');
      setTimeout(() => currentSong.classList.remove('entering'), 500);

      // マーキー効果を適用
      applyMarqueeEffect(currentTitle, currentWrapper);

      // 次の曲
      if (currentIndex < songs.length - 1 && songs[currentIndex + 1]) {
        const nextSongData = songs[currentIndex + 1];
        nextSong.querySelector('.title').textContent = nextSongData.title;
        nextSong.style.display = 'flex';
      } else {
        nextSong.style.display = 'none';
      }
    }

    // 初期化: 設定取得を先に実行してからWebSocket接続
    fetchAndApplySettings().finally(() => {
      connectWebSocket();
    });

    // ウィンドウリサイズ時にマーキー効果を再計算（OBSソースサイズ変更対応）
    const resizeObserver = new ResizeObserver(() => {
      const currentTitle = document.querySelector('#current-song .title');
      const currentWrapper = document.querySelector('#current-song .title-wrapper');
      if (currentTitle && currentWrapper && currentTitle.textContent) {
        applyMarqueeEffect(currentTitle, currentWrapper);
      }
    });
    resizeObserver.observe(document.getElementById('setlist-container'));
  </script>
</body>
</html>
